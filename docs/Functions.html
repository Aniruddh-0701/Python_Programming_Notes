<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functions in Python</title>
    <meta name="description" content="Functions in Python">
    <link rel="shortcut icon" href="./python-logo-4k.jpg" type="image/x-icon">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="./static/main.css" />
    <script
        src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?autorun=false&amp;lang=llvm&amp;lang=py"></script>
    <script src="./static/html_format.js"></script>


    <script>
        MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>
    <div class="head">
        <a href="./" style="margin: 10%;">Home</a>
        <br>
        <hr>
    </div>

    <div class="container">
        <h1>Functions in Python</h1>
        
<p>Function is a set of organized lines of code that performs a specific, well defined task.</p>
<p>It is used reduce the number of lines of code and improve reusability.</p>
<p>Syntax:  </p>
<pre><code class="language-python">def function_name(parameters):  # function definition  
    Statements
    return value(s)

...  
...  
function_name(parameters) # Caller
</code></pre>
<h4>Return statement:</h4>
<pre><code class="language-python">return
</code></pre>
<p>Returns back a value as specified. It marks the end of a function</p>
<h2>Fruitful function</h2>
<p>A fruitful function is a function that returns a value</p>
<p><code>IN [1]</code></p>
<pre><code class="language-python"># Example 1:
def add(a, b): # Function Definition
    return a + b # returns the sum
x = int(input())
y = int(input())
print(add(x, y)) # Function Calling
# Input:
# 12
# 13
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 12
 13

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">25

</code></pre>
<h3>Naming a function</h3>
<p>Like variables, python functions should also be in <code>lower_snake_case</code></p>
<p>One of the more universal, yet simple rules is: Function names should be verbs if the function changes the state of the program, and nouns if they&rsquo;re used to return a certain value.</p>
<ol>
<li><em>Self-explanatory names</em>: a function <code>get_name()</code> will tell the developer what it returns as well as set_address(), is_male(), etc.</li>
<li><em>Short</em>: a function name must be as short as possible so that it&rsquo;s simple to type as well as easy to remember. A function <code>get_number_of_pages_in_the_book()</code> is not good, something like <code>get_book_page_count()</code> is better.</li>
<li>Use of prefixes: use prefixes in the functions such as <code>get_name()</code>, <code>set_name()</code>, etc.</li>
</ol>
<p>The most important thing to note is to follow a constant naming convention throughout the function</p>
<h2>Lambda function (Inline or Anonymous function):</h2>
<p>One liner of a function. It is created for use at one point or one statememt and is not intended to be named and stored.</p>
<p>Syntax:  </p>
<pre><code class="language-python">lambda parameters: Statement
</code></pre>
<p><code>IN [9]</code></p>
<pre><code class="language-python"># Example 1

def is_even(x):
    return x % 2 == 0 # One line function to check if even

a = int(input())
print(&quot;From is_even(x):&quot;, is_even(a))
print(&quot;From lambda:&quot;, (lambda x: x % 2 == 0)(a)) # Equivalent lambda function

# Input: 10
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 10

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">From is_even(x): True
From lambda: True

</code></pre>
<p>The <code>lambda</code> function is generally created for use with iterables where the function is applied to several values but at only once (that part of the code).</p>
<p>The usual places include maps, filter and keys for sorting for any iterable. Visit <a href="DS_Lists.html">Lists</a> or <a href="DS_Tuples.html">Tuples</a> to know more on them</p>
<h2>Recursion:</h2>
<p>Recursion is a method of solving a problem where the solution depends on solutions to smaller instances of the same problem.</p>
<h2>Recursive function:</h2>
<p>A function that performs recursion.</p>
<p>A recursive function calls itself repeatedly by dividing the problem into sub problems until the solution is obtained for the smallest sub-problem.</p>
<pre><code class="language-python">def function(paramters1):
    function(parameters2) # Recursive calling
</code></pre>
<p><code>IN [14]</code></p>
<pre><code class="language-python"># Example using factorial (n! = 1 * 2 * 3 ... n) n! = n * (n-1)!
def factorial(n):
    if -1&lt;n&lt;=1: return 1 # End of recursion
    else: return n * factorial(n-1) # recursive calling

n = int(input())
print(factorial(n))
# Input: 6
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 6

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">720

</code></pre>
<p>Breaking down of problem:</p>
<pre><code class="language-python">n = 6  
n &lt;= 1 False  
6 * factorial(5)  

n = 5  
n &lt;= 1 False  
5 * factorial(4)  

n = 4  
n &lt;= 1 False  
4 * factorial(3)  

n = 3  
n &lt;= 1 False  
3 * factorial(2)  

n = 2  
n &lt;= 1 False  
2 * factorial(1)  

n = 1  
n &lt;= 1 (n==1) True  
1

Building up:

1
2 * 1  
3 * 2 * 1  
4 * 3 * 2 * 1  
5 * 4 * 3 * 2 * 1  
6 * 5 * 4 * 3 * 2 * 1  

720
</code></pre>
<p>You can find the steps in recursion below<br>
The &lsquo;|&rsquo; line indicates the same level of recursive call</p>
<p><code>IN [5]</code></p>
<pre><code class="language-python"># The indent paramter defines the offset of output. This program is to understand recursion only.
def fact(n, indent=''):
    print(indent, n, sep='')
    if 0 &lt;= n &lt;= 1: return 1
    else:
        fac = n * fact(n-1, indent + &quot;|\t&quot;)
        print(indent, fac, sep='')
        return fac

fact(6)
</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">6
|   5
|   |   4
|   |   |   3
|   |   |   |   2
|   |   |   |   |   1
|   |   |   |   2
|   |   |   6
|   |   24
|   120
720

</code></pre>
<h4>Function Arguments or Parameters: (args or params)</h4>
<p>Values passed into a function. They are optional</p>
<h5>Types:</h5>
<ol>
<li>Required Arguments</li>
<li>Keyword Arguements</li>
<li>Default Arguments</li>
<li>Variable length Arguments</li>
</ol>
<h4>1. Required Arguments:</h4>
<p>Positional Arguments.
These are arguments required to execute a function.<br>
The number of required arguments should be equal to the number of arguments passed.
If not, it will result in error.</p>
<p><code>IN [29]</code></p>
<pre><code class="language-python"># Example 
def add(a, b): # Function Definition - no. of required arguments
    return a+b # returns the sum
x = int(input())
y = int(input())
print(add(x, y)) # Function Calling - no. of args passed

# Input:
# 12
# 23
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 12
 23

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">35

</code></pre>
<p><code>IN [30]</code></p>
<pre><code class="language-python">#Example
# Example 
def add(a, b): # Function Definition - no. of required arguments
    return a+b # returns the sum
x = int(input())
y = int(input())
print(add(x)) # Function Calling - no. of args passed &lt; no. of required args
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 10
 23

</code></pre>
<p><strong>Error</strong></p>
<pre><code class="language-err">
Traceback (most recent call last):

  File &quot;D:\Programming\Python\Jupyter Notebooks\Python_Programming_Notes\temp.py&quot;, line 7, in &lt;module&gt;

    print(add(x)) # Function Calling - no. of args passed &lt; no. of required args

TypeError: add() missing 1 required positional argument: 'b'

</code></pre>
<h4>2. Keyword arguments (kwargs):</h4>
<p>These arguments are not positional but are required.</p>
<p><code>IN [20]</code></p>
<pre><code class="language-python"># Example 2
def add(a, b): # Function Definition - Parameters
    print(a, b)
    return a+b # returns the sum


x = int(input())
y = int(input())
print(add(b = x, a = y)) # Function Calling - Keywords are names of params used in definition
# Input: 10
# 23
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 10
 23

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">23 10
33

</code></pre>
<h4>3. Default arguments:</h4>
<p>Arguments which are optional. They have values by default.</p>
<p><code>IN [31]</code></p>
<pre><code class="language-python">#Example 
def add(a, b = 0): # Function Definition - b is default args
    print(a, b)
    return a+b # returns the sum
x = int(input())
y = int(input())

# b given in function call
print('B given')
print(add(x, y)) # Function Calling

print()

# b not given in function call
print('B not given default = 0')
print(add(x)) # Function Calling

# Input: 12
# 23
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 12
 23

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">B given
12 23
35

B not given default = 0
12 0
12

</code></pre>
<h3>Defining or indicating the difference in the type of args:</h3>
<p>From python 3.8, &lsquo;/&rsquo; is used to Separate positional args from non positional.</p>
<p><code>IN [32]</code></p>
<pre><code class="language-python"># Example 
def add(a, /, b=0): # Function Definition
    return a+b # returns the sum
x = int(input())
y = int(input())
print(add(x)) # Function Calling 
# Input: 10
# 23
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 10
 23

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">10

</code></pre>
<h4>4. Variable Length Arguments:</h4>
<p>Args that are used when the number of arguments is not known.
The arguments passed are stored as a tuple. The arguments that start with &lsquo; * &lsquo; indicate Variable length arguments and are called <strong>gather</strong></p>
<p><code>IN [2]</code></p>
<pre><code class="language-python">#Example
# Example 
def add(a, *b): # Function Definition -  * indicates variable length arguments
    print(b)
    return a + sum(b) # returns the sum; sum is a built in function that returns sum of elements in an iterable
x = int(input())
y = int(input())
# 2 arguments
print(add(x, y))
print()
# 3 args
print(add(x, y, 10))
print()
# 4 args
print(add(x, y, 10, 20)) # Function Calling - no. of args passed

# Input: 10
# 23
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 10
 23

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">(23,)
33

(23, 10)
43

(23, 10, 20)
63

</code></pre>
<h4>Types:</h4>
<ol>
<li>*args</li>
<li>**kwargs</li>
</ol>
<h4>1. &#42;args:</h4>
<p>Variable length arguements that are most commonly used. Stores the values as tuple</p>
<h4>2. &#42;&#42;kwargs:</h4>
<p>Variable length arguments of the form key = value. Stores the values as key-value mapping or dictionary.</p>
<p><code>IN [3]</code></p>
<pre><code class="language-python">#kwargs example
def kwargs_ex(**a):
    print(a)
    for k, v in a.items():
        print(f&quot;{k} = {v}&quot;)

kwargs_ex(x=2, y=3)
</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">{'x': 2, 'y': 3}
x = 2
y = 3

</code></pre>
<h3>Scope of variable:</h3>
<p>The part of code where a variable can be accessed.
Scopes: 
1. Global Variable
2. Local Variable</p>
<h3>1. Global Variable:</h3>
<p>Variable that can be acessed in any part of the program.</p>
<h3>2. Local Variable:</h3>
<p>Variable that can be accessed only inside a specific block or part of a program.</p>
<p><code>IN [7]</code></p>
<pre><code class="language-python">#Example
def add(a, b): 
    c = a+b
    print(c)
    #return a+b

def printf():
    print(k)

x = int(input('x:'))
y = int(input('y:'))
add(x,y)
print('Hello')
s = 10
z = -100
for i in range(5):
    k = 'Hello'
    print(k)
print(x,y,s,z)
printf()
print(k)
print(i)
print(c)

# Input:
# 10
# 23
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt">x: 10
y: 23

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">33
Hello
Hello
Hello
Hello
Hello
Hello
10 23 10 -100
Hello
Hello
4

</code></pre>
<p><strong>Error</strong></p>
<pre><code class="language-err">x:
Traceback (most recent call last):

  File &quot;D:\Programming\Python\Jupyter Notebooks\Python_Programming_Notes\temp.py&quot;, line 10, in &lt;module&gt;

    x = int(input('x:'))

ValueError: invalid literal for int() with base 10: 'x: 10'

</code></pre>
<p><code>IN [9]</code></p>
<pre><code class="language-python">def printf(): # Function definition
    global k
    k = 'Hi' #Local Variable Gloablized
    print(k)

for i in range(5):
    k = 'Hello' # Global Variable
    print(k) 

printf()
print(k)
</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">Hello
Hello
Hello
Hello
Hello
Hi
Hi

</code></pre>
<h3>Docstrings in Function:</h3>
<p>Docstrings are most commonly used in a function.
They act as descriptor of function, i.e., they describe the function.</p>
<p>Calling docstings:</p>
<pre><code class="language-python">function_name.__doc__
</code></pre>
<p><code>IN [1]</code></p>
<pre><code class="language-python">def fn():
    '''This is a docstring'''
print(fn.__doc__) # Calls docstring
</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">This is a docstring

</code></pre>
<h2>Recursion vs Iteration:</h2>
<p>Recursion involves calling function repeatedly to breakdown a problem.<br>
Iteration is solving the problem by breaking down using loops.</p>
<p>Recursion is a easy way to solve a problem. But it is a bit time consuming.
Iteration is hard coding but is efficient in solving the problems.</p>
<p>This brings in a new programming stream called Dynamic Programming.</p>
<h3>Functions seen so far:</h3>
<ol>
<li>print</li>
<li>input</li>
<li>int</li>
<li>float</li>
</ol>
<h3>1. print:</h3>
<p>Syntax:</p>
<pre><code class="language-python">print(values, end=&quot;\n&quot;, sep&quot; &quot;)
</code></pre>
<p><code>IN [3]</code></p>
<pre><code class="language-python">print(1,2,3, sep = &quot;&quot;) # no separation between the values
</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">123

</code></pre>
<p><code>IN [4]</code></p>
<pre><code class="language-python">print(1,2,3)
</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">1 2 3

</code></pre>
<p><code>IN [5]</code></p>
<pre><code class="language-python">print(1,2,3, sep = '\t')
</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">1   2   3

</code></pre>
<p><code>IN [6]</code></p>
<pre><code class="language-python">print(1,2,3)
print(4,5)
</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">1 2 3
4 5

</code></pre>
<p><code>IN [7]</code></p>
<pre><code class="language-python">print(1,2,3, end='')# end of print is &lt;none&gt;
print(4,5)
</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">1 2 34 5

</code></pre>
<p><code>IN [8]</code></p>
<pre><code class="language-python">print(1,2,3, end=' ') # end of print is &lt;space&gt;
print(4,5)
</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">1 2 3 4 5

</code></pre>
<h3>2. input:</h3>
<p>Syntax: </p>
<pre><code class="language-python">input(prompt=&quot;&quot;)
</code></pre>
<p><code>IN [10]</code></p>
<pre><code class="language-python">n = input()

# Input: 20
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 20

</code></pre>
<p><code>IN [11]</code></p>
<pre><code class="language-python">a = input(prompt = 'Prompt')

# Input: 10
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt">Prompt 10

</code></pre>
<h3>3. int:</h3>
<p>Syntax: </p>
<pre><code class="language-python">int(x, base = 10)
</code></pre>
<p><code>IN [13]</code></p>
<pre><code class="language-python">int('10')
</code></pre>
<p><code>IN [14]</code></p>
<pre><code class="language-python">b = '110'
int(b, 2)
</code></pre>
<p><code>IN [15]</code></p>
<pre><code class="language-python">x = '7af'
int(x, 16)
</code></pre>
<p><code>IN [17]</code></p>
<pre><code class="language-python">o = '75'
int(o, 8)
</code></pre>
<h3>4. float:</h3>
<p>Syntax: </p>
<pre><code class="language-python">float(x = 0)
</code></pre>
<p><code>IN [20]</code></p>
<pre><code class="language-python">float()
</code></pre>
<p><code>IN [21]</code></p>
<pre><code class="language-python">float ('1.2')
</code></pre>
<p><code>IN [22]</code></p>
<pre><code class="language-python">float(1)
</code></pre>
<p><code>IN [24]</code></p>
<pre><code class="language-python">float('12') 
</code></pre>
<h2>Multiple Functions with same name:</h2>
<p>Python does not allows multiple functions with different parameters with same name. If so exist, the last function definition replaces the first.</p>
<p><code>IN [25]</code></p>
<pre><code class="language-python">def fn():
    return 'Hi'
def fn(x,y):
    return x+y
print(fn())
print(fn(10, 5))
</code></pre>
<p><strong>Error</strong></p>
<pre><code class="language-err">
Traceback (most recent call last):

  File &quot;D:\Programming\Python\Jupyter Notebooks\Python_Programming_Notes\temp.py&quot;, line 5, in &lt;module&gt;

    print(fn())

TypeError: fn() missing 2 required positional arguments: 'x' and 'y'

</code></pre>
<h2>Gather vs Scatter:</h2>
<p>Argument given to var. args are gathered and stored together to form a tuple. This is called gather.</p>
<p>Argument given as a list/tuple is split across required variable. This is called scatter</p>
<p><code>IN [2]</code></p>
<pre><code class="language-python">#Example
def add(a, *b): # Function Definition 
    print(a, b)
    return a + sum(b) # returns the sum; sum is a built in function that returns sum of elements in an iterable

l = list(map(int, input().split()))
print(add(*l)) # Function Calling

# Input: 10
# 23
# 30
# 40
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt"> 10 23 30 40

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">10 (23, 30, 40)
103

</code></pre>
<h2>Higher Order Functions or Function Decorators:</h2>
<p>A function returning another function is called a higher order function</p>
<pre><code class="language-python">def function1(params):
    def function2(params):
        Statements

    return function2
</code></pre>
<p><code>IN [13]</code></p>
<pre><code class="language-python">def deco(k): # Higher order function / decorator
    def multiple(n):
        return n*k
    return multiple

second_multiple = deco(2)
n = int(input(&quot;Enter a num\n&quot;))
print(second_multiple(n))
</code></pre>
<p><strong>stdin</strong></p>
<pre><code class="language-txt">Enter a num
 6

</code></pre>
<p><strong>stdout</strong></p>
<pre><code class="language-txt">12

</code></pre>
    </div>


</body>

</html>